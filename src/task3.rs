#[test]

/*
/* Adding trait bounds to make it work */
fn f<'a, 'b>(x: &'a i32, mut y: &'b i32) {
    y = x;
    let r: &'b &'a i32 = &&0;
}

fn main() {
    println!("Success!")
}
*/
fn main() {
    let value_a = 42;
    let mut value_b = 10;

    // Виклик функції f
    f(&value_a, &mut value_b);

    println!("value_b after f: {}", value_b);
    println!("Success!");
}
fn f<'a, 'b>(x: &'a i32, y: &'b mut i32) {
    // Призначаємо `x` до `y`, потрібно використовувати `&mut`
    *y = *x; // Використовуємо розіменування для присвоєння значення
    let _r: &'b i32 = &0; // Тепер `r` — посилання на значення з тривалістю 'b
}




/*
Зміна типу y:
Я змінив тип параметра y з &'b i32 на &'b mut i32, що дозволяє модифікувати значення, на яке вказує y.

Призначення *y = *x;:
Використовується розіменування, щоб скопіювати значення з x в y. Це працює, оскільки y тепер є змінним посиланням.

Оголошення r:
Я змінив let r: &'b &'a i32 = &&0; на let r: &'b i32 = &0;, так як ми не можемо привласнити 'a до 'b для константи.
*/